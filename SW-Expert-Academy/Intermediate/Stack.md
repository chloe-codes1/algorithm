# Stack


- 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조
- 선형 구조를 가짐 <br/>
  : 자료 간의 관계가 1대 1의 관계 <br/>
   (비선형구조는 1대  N ex. Tree)
- 마지막에 삽입한 자료를 가장 먼저 꺼냄<br>
    -> LIFO (= Last In First Out)

<br/>

 > 자료구조

  : 파이썬에서는 list를 사용할 수 있음

 마지막 삽입된 원소의 위치를 top이라 부름


 <br/>

 > 연산

 삽입 :  push  <br/>
 삭제 :  pop <br/>


<br/>

> 고려사항

리스트의 크기를 변경하는 작업은 내부적으로 큰 overhead 발생  

-> 많은 시간 소요

(Solutions)

- 리스트의 크기가 변동되지 않도록 배열처럼 크기를 미리 정해놓고 사용
- 동적 연결 리스트를 이용하여 저장소를 동적으로 할당하여 스택 구현


<br/>

### Stack 응용하기

#### 1. 괄호 검사

괄호의 종류
: 대괄호 [ ]  /  중괄호  { }  /  소괄호  ( )

조건
1. 왼쪽 괄호 개수와 오른쪽 괄호 개수가 같아야 함
2. 같은 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 함
3. 괄호 사이에는 포함 관계만 존재함

=> 왼쪽 괄호를 만나면 스택에 삽입
=> 오른쪽 괄호 만나면 스택에서 top 괄호 pop한 후 오른쪽 괄호와 짝이 맞는지 확인


<br/>

#### 2. 함수 호출 관리 (Function Call)
: 프로그램에서의 함수 호출과 복귀에 따른 수행 순서를 관리

- 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 후입선출 구조이므로, 후입선출 구조의 스택을 이용하여 수행순서 관리
- 함수 호출 시 호출한 홤수 수행에 필요한 local variable, parameter, 수행 후 복귀 할 주소를 Stack에 저장하여 System Stack에 삽입
- 함수의 실행이 끝나면 시스템 스택의 top원소를 pop하면서 stack에 저장되어있던 복귀주소를 확인하고 복귀
- 호출 & 복귀가 반복 된 후 공백 스택이 됨

<br/>


> 재귀 호출
1. 자기 자신을 호출
2. 일반적 호출 방식보다 재귀 호출 방식을 사용하면 프로그램의 크기를 줄이고 간단하게 작성할 수 있음 <br/>
   => but, 디버깅이 어렵고 잘못 작성하면 수행시간 많이 소용됨


예) Factorial, 피보나치 수열


<br/>

#### Memoization
: 프로그램 실행 시 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체 실행속도 높이는 기술

  => DP (Dynamic Programming)의 핵심이 되는 기술!


> 피보나치 수열에 DP 활용 예시 1

```python
def fibo1(n):
    global memo
    if n>=2 and len(memo) <= n:
        memo.append(fibo1(n-1) + fibo1(n-2))
    return memo[n]

memo = [0,1]
```

<br/>

#### DP (= Dynamic Programming)

: Greedy Algorithm 과 같이 최적화 문제를 해결하는 알고리즘

- 입력 크기가 작은 부분 문제들을 모두 해결한 후에 그 해들을 이용하여 더 큰 크기의 부분 문제들을 해결
- 최종적으로 원래 주어진 입력의 문제를 해결


<br/>

> 피보나치 수를 DP에 적용한 예시 2
```python
def fibo2(n):
    f = [0,1]
    for i in range(2, n+1):
        f.append(f[i-1] + f[i-2])
    return f[n]
```


<br/>

> DP 구현 방식
1. recursive 방식 : fibo1() <br/>
   => 재귀적 구조는 내부에 시스템 호출 stack을 사용하는 overhead가 발생할 수 있음

2. iterative 방식 : fibo2() <br/>
   => Memoization을 재귀적 구조에 사용하는 것보다 반복적 구조로 DP를 구현한 것이 성능 면에서 보다 효율적


<br/>
<br/>


### DFS (깊이 우선 탐색)

비선형구조인 그래프 구조는 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것이 중요 <br/>

1. 깊이 우선 탐색 <br/>
   : DFS (= Dept First Search)

2. 너비 우선 탐색 <br/>
   : BFS (= Breadth First Search) 




#### DFS (깊이 우선 탐색) 방법
- 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색
- 더 이상 갈 곳이 없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아옴
- 다른 방향의 정점으로 탐색을 계속 반복, 모든 정점 순회

 => 가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 깊이 우선 탐색 반복
        -> LIFO 구조 Stack 사용


<br/>

> DFS Algorithm
- 한 쪽 방향으로 계속 탐색하다가 더 이상 진행 할 수 없으면 다시 돌아오는 방법
- 다시 되돌아 오기 위해 자료구조 중 스택 사용



<br/>



### 문자열 계산식

> Stack을 이용하여 결과값 계산





#### 문자열 수식 계산의 일반적 방법

1. 중위표기법 (Infix notation)의 수식을 후위표기법 (Postfix notation)으로 변경
2. 후위표기법의 수식을 스택을 이용하여 계산



* 중위표기법: 연산자를 피연산자의 가운데 표기하는 방법
  * ex) A+B
* 후위표기법: 연산자를 피연산자 뒤에 표기하는 방멉
  * ex) AB+



<br/>



#### Step1 ) Stack을 이용한 중위표기식의 후위표기식으로의 변환

1. 입력 받은 중위표기식에서 토큰을 읽음

2. 토큰이 피연산자이면 토큰을 출력

3. 토큰이 연산자(괄호포함)일 경우

   - 우선순위가 높으면 ---> Stack에 push

   - 우선순위가 높지 않으면 ---> 연산자의 우선순위가 토큰의 우선순위보다 작을 때까지 Stack에서 pop한 후 Token의 연산자를 push

   - 만약 top에 연산자가 없으면  ---> push

4. 토큰이 오른쪽 괄호 ')'일 경우

   - Stack top에 왼쪽 괄호 '('가 올 때까지 Stack에 pop 연산을 수행

   - pop한 연산자를 출력
   - 단, 왼쪽 괄호를 만나면 pop만하고 출력하지는 않음

5. 중위표기식에 읽을 것 없을 때까지 1-4 반복

6. Stack에 남아 있는 연산자를 모두 pop하여 출력

   - Stack 밖의 왼쪽 괄호는 우선 순위가 가장 높음
   - Stack 안의 왼쪽 괄호는 우선 순위가 가장 낮음



<br/>



#### Step2) 후위표기법의 수식을 스택을 이용하여 계산

1. 피연산자를 만나면 Stack에 push함
2. 연산자를 만나면 필요한 만큼의 피연산자를 Stack에서 pop하여 연산하고, 연산결과를 다시 Stack에 push 함

3. 수식이 끝나면, Stack을 pop하여 출력

   ​	** 주의) 후위 표기식 계산 시, 피연산자를 Stack에 쌓아 계산!





#### 수식을 eval() 내장 함수로 계산 

> Stack을 두 번 사용해서 처리했던 연산을 eval() 내장 함수로 계산할 수 있음



`eval(수식)`

: 문자열로 된 수식을 계산함

